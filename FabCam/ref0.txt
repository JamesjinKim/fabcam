sudo lsof -i :8000
sudo kill -9 PID

● 🔍 다중 클라이언트 스트리밍 문제 분석 리뷰

  📋 현재 코드 구조 분석

  스트리밍 방식:
  - rpicam-vid 직접 실행으로 MJPEG 스트림 생성
  - 각 클라이언트마다 별도의 subprocess.Popen 프로세스 생성
  - FastAPI StreamingResponse로 HTTP 스트리밍

  병목 지점:
  1. CPU 인코딩 부하: 각 클라이언트당 개별 rpicam-vid 프로세스 (30 FPS MJPEG)
  2. 메모리 사용량: 클라이언트 수 × 프로세스 메모리
  3. I/O 병목: 개별 프로세스의 stdout 파이프 경합

  🔧 라즈베리파이 5 하드웨어 현실

  ❌ 하드웨어 가속 한계:
  - VideoCore VII GPU: 하드웨어 인코더 없음 (디코더만 지원)
  - VAAPI: Intel 전용, 라즈베리파이 미지원
  - V4L2 M2M: 라즈베리파이 5에서 제거됨
  - 하드웨어 인코딩: 이전 모델 대비 기능 퇴화

  💡 실질적인 개선 방안

  1. 스트림 공유 아키텍처 (추천)
  # 단일 rpicam-vid → 다중 클라이언트 배포
  class SharedStreamManager:
      def __init__(self):
          self.active_streams = {}  # camera_id: shared_buffer
          self.clients = {}  # camera_id: [client_list]

  2. 해상도/품질 최적화
  # 현재: 640x480 @ 30fps MJPEG
  # 개선: 320x240 @ 15fps 또는 quality 조정
  rpicam-vid --width 320 --height 240 --framerate 15 --quality 60

  3. WebRTC/WebSocket 전환
  - HTTP streaming → WebRTC P2P
  - 서버 부하 분산
  - 더 효율적인 압축

  4. nginx-rtmp 중계서버
  # 단일 스트림 → nginx → 다중 클라이언트
  rtmp {
      server {
          application live {
              live on;
              hls on;
          }
      }
  }

  🚫 비추천 방법들
  1. ffmpeg 하드웨어 가속: 라즈베리파이 5에서 불가능
  2. GStreamer V4L2: 하드웨어 인코더 부재로 효과 제한
  3. GPU 가속: VideoCore VII 인코더 미지원

  📊 성능 예상 개선치

  | 방법      | 현재       | 개선 후    | 클라이언트 수 |
  |---------|----------|---------|---------|
  | 개별 프로세스 | 100% CPU | -       | 1-2개    |
  | 스트림 공유  | 100% CPU | 30% CPU | 5-10개   |
  | 해상도 절반  | 100% CPU | 25% CPU | 10-15개  |
  | WebRTC  | 100% CPU | 20% CPU | 15-20개  |

  🎯 결론

  라즈베리파이 5에서는 하드웨어 가속보다 소프트웨어 아키텍처 개선이 핵심입니다:
  1. 즉시 개선: 스트림 공유 구조로 변경
  2. 성능 조정: 해상도/프레임레이트 최적화
  3. 장기 개선: WebRTC 도입 검토
  하드웨어 가속은 라즈베리파이 5의 구조적 한계로 불가능하므로, 효율적인 소프트웨어 설계가 유일한 해결책입니다.
<---------- 완료 ----------->

● 📋 녹화 및 캡처 기능 분석 결과 및 개선 제안

  🔍 현재 상태 분석

  1. 캡처 기능 (현재 동작함)

  - ✅ API: /api/snapshot/{camera_id} 구현됨
  - ✅ 구현: camera.py의 capture_snapshot() 동작
  - ✅ 최적화: 스트림 실행 중이면 최신 프레임 사용, 없으면 rpicam-still 사용
  - ✅ 프론트엔드: 정상 연동

  2. 녹화 기능 (미구현 상태)

  - ❌ API: 501 Not Implemented 상태
  - ❌ 백엔드: main.py L130-136에서 TODO 상태
  - ❌ 프론트엔드: L262에서 비활성화 처리

  🎯 개선 제안

  A. 스트림 공유 기반 녹화 아키텍처

  class RecordingManager:
      """스트림 공유 구조와 호환되는 녹화 매니저"""

      def __init__(self):
          self.recording_processes = {}  # camera_id: recording_process
          self.recording_status = {
              "is_recording": False,
              "cameras": [],  # 녹화 중인 카메라 목록
              "start_time": None,
              "output_files": []
          }

  B. 녹화 방식 선택지

  1. 🥇 추천: 별도 rpicam-vid 녹화 프로세스 (안정성 최고)
  # 스트리밍과 독립적인 별도 프로세스
  rpicam-vid --camera 0 --width 640 --height 480 --framerate 30 \
             --codec h264 --output video_20250822_093045.mp4 --timeout 0

  2. 🥈 대안: 공유 스트림 데이터 저장 (효율성 높음)
  - SharedStreamManager에서 MJPEG 프레임을 MP4로 변환 저장
  - ffmpeg 파이프라인 사용

  3. 🥉 하이브리드: 스트리밍 + 녹화 멀티캐스트
  - 단일 rpicam-vid에서 tee를 사용한 멀티 출력

  C. 구체적 구현 계획

  1. 백엔드 개선:
  # SharedStreamManager에 녹화 기능 추가
  class SharedStreamManager:
      def start_recording(self, output_path: str) -> bool
      def stop_recording(self) -> Optional[str]
      def is_recording(self) -> bool

  # CameraManager에 녹화 관리 기능 추가  
  class CameraManager:
      def start_recording(self, camera_ids: List[int]) -> bool
      def stop_recording(self) -> Dict[int, str]
      def get_recording_status(self) -> RecordingStatus

  2. API 엔드포인트 구현:
  @app.post("/api/recording/start")
  async def start_recording(cameras: List[int] = [0, 1])

  @app.post("/api/recording/stop")
  async def stop_recording()

  @app.get("/api/recording/status")
  async def get_recording_status()

  3. 프론트엔드 활성화:
  - toggleRecording() 함수 구현
  - 녹화 상태 UI 업데이트
  - 실시간 녹화 시간 표시

  D. 성능 고려사항

  | 방식      | CPU 사용률   | 안정성   | 구현 복잡도 | 추천도 |
  |---------|-----------|-------|--------|-----|
  | 별도 프로세스 | 높음 (+30%) | ⭐⭐⭐⭐⭐ | 낮음     | 🥇  |
  | 스트림 저장  | 중간 (+15%) | ⭐⭐⭐⭐  | 중간     | 🥈  |
  | 하이브리드   | 낮음 (+10%) | ⭐⭐⭐   | 높음     | 🥉  |

  E. 개선 우선순위

  1. 즉시 구현 (1-2시간):
    - 별도 rpicam-vid 녹화 프로세스 방식
    - 기본 녹화 시작/중지 API
    - 프론트엔드 활성화
  2. 단기 개선 (1-2일):
    - 다중 카메라 동시 녹화
    - 녹화 설정 (해상도, 품질, 시간 제한)
    - 자동 파일 관리
  3. 장기 최적화 (1주일):
    - 스트림 공유 기반 녹화로 전환
    - 녹화 중 실시간 미리보기
    - 스케줄링 녹화

  🚀 구현 권장사항

  가장 효과적인 접근법:
  1. 별도 프로세스 방식으로 빠른 구현
  2. 스트림 공유 구조는 그대로 유지
  3. 안정성과 단순함을 우선시
  4. 추후 성능 최적화는 점진적 개선

  이 방식으로 구현하면 스트리밍 안정성을 해치지 않으면서 녹화 기능을 안전하게 추가할 수 있습니다.


  ● 라즈베리파이 5에서 카메라 인식을 테스트할 수 있는 명령어들을
  알려드리겠습니다:

  카메라 인식 테스트 명령어

  1. 기본 카메라 목록 확인
  rpicam-hello --list-cameras

  2. 간단한 카메라 테스트 (5초간 미리보기)
  rpicam-hello --camera 0 --timeout 5000

  3. 카메라 정보 상세 확인
  rpicam-hello --camera 0 --info-text fps --timeout 3000

  4. 정지 이미지 캡처 테스트
  rpicam-still --camera 0 --output test_camera0.jpg --timeout 1000

  5. 비디오 캡처 테스트 (5초)
  rpicam-vid --camera 0 --timeout 5000 --output test_camera0.mp4


  ● 💡 최종 결론

  1280×720 해상도 변경은 기술적으로 완전히 가능하며, 두 카메라 모두 정상 지원합니다.

  핵심 고려사항:
  - 화질: 3배 향상된 선명도
  - 성능: 3배 증가한 처리 부하
  - 네트워크: 3배 증가한 대역폭 요구
  - 안정성: 현재 시스템이 안정적이므로 위험 요소

  추천 접근법:
  1. 점진적 테스트: 스트리밍부터 단계별 적용
  2. 성능 모니터링: CPU/메모리 사용률 실시간 체크
  3. 롤백 준비: 성능 이슈 시 즉시 640×480으로 복원

  현재 시스템이 안정적으로 동작하고 있어서, 더 높은 해상도가 꼭 필요한 상황이 아니라면 현재 
  640×480 유지를 권장합니다.